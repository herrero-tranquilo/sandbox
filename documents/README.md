## Javascript

자바스크립트는 복잡한 무언가(주기적으로 내용이 갱신되는 기능이나 능동적인 지도, 변화하는 2D/3D 그래픽, 동영상 등)를
웹페이지에 적용할 수 있게 하는 스크립트 혹은 프로그래밍 언어입입니다.

### Browser API

Browser API는 웹 브라우저에 설치된 API들로, 컴퓨터 환경구성으로 부터 데이터를 보이게 하고 복잡한 일들을 하게 합니다. 예를 들어:

#### DOM (Document Object Model) API

```
동적으로 페이지의 스타일을 정하는 등 HTML과 CSS를 알맞게 조정하는 역할을 합니다.
우리가 매일 보는 팝업창이나, 위의 사진과 같이 컨텐츠들이 보여지는 것들이 모두 DOM의 결과라고 볼 수 있습니다.
```

#### Geolocation API

```
지리적인 정보를 검색하게 해줍니다.
이는 Google Maps이 어떻게 위치를 찾고 지도에 표시하는지 알 수 있게 합니다.
```

#### Canvas 와 WebGL API

```
2D와 3D 그래픽을 만들 수 있도록 합니다. 이러한 웹 기술을 사용하여 다양하고 재미있는 것들을 지원합니다.
—Chrome Experiments 와 webglsamples을 참조해보세요.
```

#### Audio and Video API(HTMLMediaElement 와 WebRTC 등)

```
 Audio and Video API는 음악과 비디오를 웹 페이지 상에서 재생하고,
 웹캠으로 캡처하고 다른 컴퓨터에 표시하는 등의 멀티미디어를 활용할 수 있는 재미있는 기술을 지원합니다.
```

### 해석형 언어와 컴파일러형 언어

```
프로그래밍을 하는 입장에서 인터프리트와 컴파일이라는 개념에 대해서는 들어보았을 것입니다.
자바스크립트는 해석형 언어입니다. 따라서 코드가 위에서 아래로 순차적으로 실행되고 그 즉시 결과가 반환됩니다.
브라우저에서 동작하기 전에 다른 방식으로 코드를 변환할 필요가 없습니다.

반면에 컴파일러형 언어는 컴퓨터에 의해 동작되기전 다른 형식으로 변환하는 언어입니다.
예를 들면 C/C++과 같은 언어는 어셈블리어로 컴파일되어 동작됩니다.

```

### 서버측 코드와 클라이언트측 코드

```
웹 개발 맥락에서 서버측과 클라이언트측 코드에 대해 들어보았을 것입니다.
클라이언트측 코드란 사용자의 컴퓨터에서 작동되는 코드입니다.
만약 웹페이지를 보고자 한다면, 클라이언트측 코드가 사용자의 컴퓨터로 다운로드되고 브라우저가 이를 표시합니다.
이러한 자바스크립트 모듈을 정확히는 클라이언트측 자바스크립트라고 합니다.

반면 서버측 코드는 서버에서 작동되고, 그 결과가 사용자의 브라우저에 넘어가 표시됩니다.
PHP, Python, Ruby, ASP.NET등이 서버측 웹 언어의 대표적 예라고 볼 수 있습니다.
물론 자바스크립트도 가능합니다.
Node.js란 환경을 통해 서버측에서도 자바스크립트가 사용 가능합니다.
Dynamic Websites – Server-side programming에서 서버측 자바스크립트에 대해 더 알 수 있습니다.
```

### 동적 VS 정적 코드

```
"동적"이라는 말은 클라이언트측 서버측 언어 모두를 가르킵니다.
이는 각기 다른 상황에서 적절한 정보가 보이고, 컨텐츠를 웹페이지나 앱 상에 계속적으로 노출시키는 역할을 합니다.
서버측 코드는 데이터베이스로 부터 데이터를 던지는 등 동적으로 새로운 컨텐츠들을 만듭니다.
반면에, 클라이언트측 자바스크립트는 새로운 HTML 표를 만들어 서버에서 요청한 데이터를 뿌려 사용자에게 보이는 등
동적으로 브라우저 안에서 작동됩니다.
이 둘 사이는 서로 미묘한 차이가 있지만, 서로 연관되어 있고 서버측 클라이언트측의 관계와 접근에 대해 알 필요가 있습니다.

동적으로 바뀌지 않는 페이지를 "정적"페이지라고 합니다. (항상 같은 콘텐츠를 보여줍니다.)
```

### 스크립트의 로딩 방법

```
작성된 스크립트를 브라우저가 적절한 때에 로딩하는것에 대해 몇가지 이슈가 있습니다.
중요한 것은 모든 HTML 요소는 순서대로 페이지에 로드된다는 것입니다.
만약 당신이 자바스크립트를 이용해 HTML 요소를 조작할 경우(정확하게는 DOM), 자바스크립트 코드가
조작 대상인 HTML 요소보다 먼저 실행된다면 조작할 요소가 존재하지 않는 상태이기 때문에 제대로 동작하지 않을 것입니다.

<head>
    <script>
        var el=document.getElementById(id);
        ...
    </script>
</head>
<body></body>

위의 코드 예제에서, 내부와 외부의 자바스크립트는 HTML Document의 body가 해석되기 전인 head 부분에 로드되고 실행되었습니다.
이는 에러를 일으킬 수 있습니다. 그래서 여기에 사용되는 몇가지 해결방법들이 있습니다.

내부 자바스크립트 예제에서는 다음과 같이 구성하면 됩니다:

document.addEventListener("DOMContentLoaded", function() {
 ...
});

이 이벤트리스너는 "DOMContentLoad" 이벤트가 발생되었을 때 function()을 실행한다는 의미입니다.
"DOMContentLoad" 이벤트는 브라우저가 완전히 로드되고 해석될때 발생됩니다.
function(){} 내부의 자바스크립트 구문은 이벤트가 발생되기 전까지는 실행되지 않습니다.
따라서 모든 body태그의 요소가 로드된 이후 자바스크립트 코드가 실행되도록 만들어 에러를 피할 수 있습니다.

외부 자바스크립트 예제에서는 좀더 최신의 자바스크립트 문법인 async 속성을 사용하게 됩니다.
일반적으로 HTML요소를 로딩하는 중 <scirpt>태그를 만나면 JavaScript의 내용이 모두 다운될 때까지 HTML로딩은 멈추게 되는데,
async요소는 비동기방식으로 <script>태그에 도달했을 때 브라우저에게 HTML 요소를 멈추지 않고 다운받도록 유지시킵니다.

<script src="script.js" async></script>
이 경우 script와 HTML은 모두 동시에 로드되고 작동할 것입니다.

Note: 외부 스크립트 경우 async 속성을 사용하면 되기 때문에 내부 스크립트처럼 DOMContentLoaded이벤트를 사용할 필요가 없습니다.
하지만 async속성은 외부 스크립트의 경우만 동작합니다.

예전 방식은 scirpt 요소를 body태그의 맨 끝에 넣는 방법이었습니다(</body> 바로 위).
이 방식을 사용해도 body태그가 모두 로드된 이후 scirpt가 실행되게 만들 수 있습니다.
문제는 이 방법과 DOMContentLoaded를 이용한 방법 모두 HTML DOM이 로드되기 전까지 script의 로딩과 파싱이 완전히 차단된다는 것입다.
이는 많은 자바스크립트 코드를 다루는 규모가 큰 사이트의 경우 사이트를 느리게 만드는 중요한 성능 문제를 야기할 수 있습니다.
이것이 async 속성을 사용해야 하는 이유입니다.

Note: 자바스크립트의 비동기 개념은 이해하는데 시간이 오래 걸리기 때문에, 지금 이해되지 않는다면 현재 단계에선 외부 스크립트 방식만 사용하고 넘어가도 무방합니다.
```
